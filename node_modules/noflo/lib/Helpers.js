(function() {
  var StreamReceiver, StreamSender,
    __hasProp = {}.hasOwnProperty;

  StreamSender = require('./Streams').StreamSender;

  StreamReceiver = require('./Streams').StreamReceiver;

  exports.MapComponent = function(component, func, config) {
    var groups, inPort, outPort;
    if (!config) {
      config = {};
    }
    if (!config.inPort) {
      config.inPort = 'in';
    }
    if (!config.outPort) {
      config.outPort = 'out';
    }
    inPort = component.inPorts[config.inPort];
    outPort = component.outPorts[config.outPort];
    groups = [];
    return inPort.process = function(event, payload) {
      switch (event) {
        case 'connect':
          return outPort.connect();
        case 'begingroup':
          groups.push(payload);
          return outPort.beginGroup(payload);
        case 'data':
          return func(payload, groups, outPort);
        case 'endgroup':
          groups.pop();
          return outPort.endGroup();
        case 'disconnect':
          groups = [];
          return outPort.disconnect();
      }
    };
  };

  exports.WirePattern = function(component, config, proc) {
    var collectGroups, completeParamsCount, groupedData, groupedDataGroups, inPorts, name, outPorts, port, processQueue, q, requiredParamsCount, taskQ, _fn, _fn1, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1;
    inPorts = 'in' in config ? config["in"] : 'in';
    if (!(inPorts instanceof Array)) {
      inPorts = [inPorts];
    }
    outPorts = 'out' in config ? config.out : 'out';
    if (!(outPorts instanceof Array)) {
      outPorts = [outPorts];
    }
    if (!('async' in config)) {
      config.async = false;
    }
    if (!('ordered' in config)) {
      config.ordered = false;
    }
    if (!('group' in config)) {
      config.group = false;
    }
    if (!('field' in config)) {
      config.field = null;
    }
    if (!('forwardGroups' in config)) {
      config.forwardGroups = false;
    }
    if (!('receiveStreams' in config)) {
      config.receiveStreams = false;
    }
    if (typeof config.receiveStreams === 'string') {
      config.receiveStreams = [config.receiveStreams];
    }
    if (!('sendStreams' in config)) {
      config.sendStreams = false;
    }
    if (typeof config.sendStreams === 'string') {
      config.sendStreams = [config.sendStreams];
    }
    if (config.async) {
      config.sendStreams = outPorts;
    }
    if (!('params' in config)) {
      config.params = [];
    }
    collectGroups = config.forwardGroups;
    if (typeof collectGroups === 'boolean' && !config.group) {
      collectGroups = inPorts;
    }
    if (typeof collectGroups === 'string' && !config.group) {
      collectGroups = [collectGroups];
    }
    if (collectGroups !== false && config.group) {
      collectGroups = true;
    }
    for (_i = 0, _len = inPorts.length; _i < _len; _i++) {
      name = inPorts[_i];
      if (!component.inPorts[name]) {
        throw new Error("no inPort named '" + name + "'");
      }
    }
    for (_j = 0, _len1 = outPorts.length; _j < _len1; _j++) {
      name = outPorts[_j];
      if (!component.outPorts[name]) {
        throw new Error("no outPort named '" + name + "'");
      }
    }
    groupedData = {};
    groupedDataGroups = {};
    q = [];
    processQueue = function() {
      var flushed, key, stream, streams;
      while (q.length > 0) {
        streams = q[0];
        flushed = false;
        if (outPorts.length === 1) {
          if (streams.resolved) {
            flushed = streams.flush();
            if (flushed) {
              q.shift();
            }
          }
        } else {
          for (key in streams) {
            stream = streams[key];
            if (stream.resolved) {
              flushed = stream.flush();
              if (flushed) {
                q.shift();
              }
            }
          }
        }
        if (!flushed) {
          return;
        }
      }
    };
    if (config.async) {
      if ('load' in component.outPorts) {
        component.load = 0;
      }
      component.beforeProcess = function(outs) {
        if (config.ordered) {
          q.push(outs);
        }
        component.load++;
        if ('load' in component.outPorts && component.outPorts.load.isAttached()) {
          component.outPorts.load.send(component.load);
          return component.outPorts.load.disconnect();
        }
      };
      component.afterProcess = function(err, outs) {
        processQueue();
        component.load--;
        if ('load' in component.outPorts && component.outPorts.load.isAttached()) {
          component.outPorts.load.send(component.load);
          return component.outPorts.load.disconnect();
        }
      };
    }
    taskQ = [];
    component.params = {};
    requiredParamsCount = 0;
    completeParamsCount = 0;
    _ref = config.params;
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      port = _ref[_k];
      if (!component.inPorts[port]) {
        throw new Error("no inPort named '" + port + "'");
      }
      if (component.inPorts[port].isRequired()) {
        requiredParamsCount++;
      }
    }
    _ref1 = config.params;
    _fn = function(port) {
      var inPort;
      inPort = component.inPorts[port];
      return inPort.process = function(event, payload) {
        var task, _results;
        if (event !== 'data') {
          return;
        }
        component.params[port] = payload;
        completeParamsCount = Object.keys(component.params).length;
        if (completeParamsCount >= requiredParamsCount && taskQ.length > 0) {
          _results = [];
          while (taskQ.length > 0) {
            task = taskQ.shift();
            _results.push(task());
          }
          return _results;
        }
      };
    };
    for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
      port = _ref1[_l];
      _fn(port);
    }
    _fn1 = function(port) {
      var inPort;
      if (config.receiveStreams && config.receiveStreams.indexOf(port) !== -1) {
        inPort = new StreamReceiver(component.inPorts[port]);
      } else {
        inPort = component.inPorts[port];
      }
      inPort.groups = [];
      return inPort.process = function(event, payload) {
        var data, g, groups, grp, key, out, outs, p, requiredLength, task, whenDone, _len5, _len6, _len7, _len8, _len9, _n, _o, _p, _q, _r, _ref2;
        switch (event) {
          case 'begingroup':
            return inPort.groups.push(payload);
          case 'endgroup':
            return inPort.groups.pop();
          case 'data':
            key = '';
            if (config.group && inPort.groups.length > 0) {
              key = inPort.groups.toString();
              if (config.group instanceof RegExp) {
                if (!config.group.test(key)) {
                  key = '';
                }
              }
            } else if (config.field && typeof payload === 'object' && config.field in payload) {
              key = payload[config.field];
            }
            if (!(key in groupedData)) {
              groupedData[key] = {};
            }
            if (config.field) {
              groupedData[key][config.field] = key;
            }
            if (inPorts.length === 1) {
              groupedData[key] = payload;
            } else {
              groupedData[key][port] = payload;
            }
            if (collectGroups instanceof Array && collectGroups.indexOf(port) !== -1) {
              if (!(key in groupedDataGroups)) {
                groupedDataGroups[key] = [];
              }
              _ref2 = inPort.groups;
              for (_n = 0, _len5 = _ref2.length; _n < _len5; _n++) {
                grp = _ref2[_n];
                if (groupedDataGroups[key].indexOf(grp) === -1) {
                  groupedDataGroups[key].push(grp);
                }
              }
            }
            requiredLength = inPorts.length;
            if (config.field) {
              ++requiredLength;
            }
            if (requiredLength === 1 || Object.keys(groupedData[key]).length === requiredLength) {
              if (collectGroups === true) {
                groups = inPort.groups;
              } else {
                groups = groupedDataGroups[key];
              }
              for (_o = 0, _len6 = inPorts.length; _o < _len6; _o++) {
                p = inPorts[_o];
                component.inPorts[p].groups = [];
              }
              outs = {};
              for (_p = 0, _len7 = outPorts.length; _p < _len7; _p++) {
                name = outPorts[_p];
                if (config.async || config.sendStreams && config.sendStreams.indexOf(name) !== -1) {
                  outs[name] = new StreamSender(component.outPorts[name], config.ordered);
                } else {
                  outs[name] = component.outPorts[name];
                }
              }
              if (outPorts.length === 1) {
                outs = outs[outPorts[0]];
              }
              whenDone = function(err) {
                var g, out, _len8, _len9, _q, _r;
                if (err) {
                  component.error(err, groups);
                }
                if (typeof component.fail === 'function' && component.hasErrors) {
                  component.fail();
                }
                if (outPorts.length === 1) {
                  if (config.forwardGroups) {
                    for (_q = 0, _len8 = groups.length; _q < _len8; _q++) {
                      g = groups[_q];
                      outs.endGroup();
                    }
                  }
                  outs.disconnect();
                } else {
                  for (name in outs) {
                    out = outs[name];
                    if (config.forwardGroups) {
                      for (_r = 0, _len9 = groups.length; _r < _len9; _r++) {
                        g = groups[_r];
                        out.endGroup();
                      }
                    }
                    out.disconnect();
                  }
                }
                if (typeof component.afterProcess === 'function') {
                  return component.afterProcess(err || component.hasErrors, outs);
                }
              };
              data = groupedData[key];
              delete groupedData[key];
              delete groupedDataGroups[key];
              if (typeof component.beforeProcess === 'function') {
                component.beforeProcess(outs);
              }
              if (outPorts.length === 1) {
                if (config.forwardGroups) {
                  for (_q = 0, _len8 = groups.length; _q < _len8; _q++) {
                    g = groups[_q];
                    outs.beginGroup(g);
                  }
                }
              } else {
                for (name in outs) {
                  out = outs[name];
                  if (config.forwardGroups) {
                    for (_r = 0, _len9 = groups.length; _r < _len9; _r++) {
                      g = groups[_r];
                      out.beginGroup(g);
                    }
                  }
                }
              }
              if (config.async) {
                task = function() {
                  return proc(data, groups, outs, whenDone);
                };
              } else {
                task = function() {
                  proc(data, groups, outs);
                  return whenDone();
                };
              }
              if (completeParamsCount >= requiredParamsCount) {
                return task();
              } else {
                return taskQ.push(task);
              }
            }
        }
      };
    };
    for (_m = 0, _len4 = inPorts.length; _m < _len4; _m++) {
      port = inPorts[_m];
      _fn1(port);
    }
    return component;
  };

  exports.GroupedInput = exports.WirePattern;

  exports.CustomError = function(message, options) {
    var err;
    err = new Error(message);
    return exports.CustomizeError(err, options);
  };

  exports.CustomizeError = function(err, options) {
    var key, val;
    for (key in options) {
      if (!__hasProp.call(options, key)) continue;
      val = options[key];
      err[key] = val;
    }
    return err;
  };

  exports.MultiError = function(component, group, errorPort) {
    if (group == null) {
      group = '';
    }
    if (errorPort == null) {
      errorPort = 'error';
    }
    if (!(errorPort in component.outPorts)) {
      throw new Error("Missing error port '" + errorPort + "'");
    }
    component.hasErrors = false;
    component.errors = [];
    component.error = function(e, groups) {
      if (groups == null) {
        groups = [];
      }
      component.errors.push({
        err: e,
        groups: groups
      });
      return component.hasErrors = true;
    };
    component.fail = function(e, groups) {
      var error, grp, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      if (e == null) {
        e = null;
      }
      if (groups == null) {
        groups = [];
      }
      if (e) {
        component.error(e, groups);
      }
      if (!component.hasErrors) {
        return;
      }
      if (group) {
        component.outPorts[errorPort].beginGroup(group);
      }
      _ref = component.errors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        error = _ref[_i];
        _ref1 = error.groups;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          grp = _ref1[_j];
          component.outPorts[errorPort].beginGroup(grp);
        }
        component.outPorts[errorPort].send(error.err);
        _ref2 = error.groups;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          grp = _ref2[_k];
          component.outPorts[errorPort].endGroup();
        }
      }
      if (group) {
        component.outPorts[errorPort].endGroup();
      }
      component.outPorts[errorPort].disconnect();
      component.hasErrors = false;
      return component.errors = [];
    };
    return component;
  };

}).call(this);
