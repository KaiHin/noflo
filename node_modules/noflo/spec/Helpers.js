var Substream, chai, component, helpers, socket;

if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
  if (!chai) {
    chai = require('chai');
  }
  helpers = require('../src/lib/Helpers');
  component = require('../src/lib/Component');
  socket = require('../src/lib/InternalSocket');
  Substream = require('../src/lib/Streams').Substream;
} else {
  helpers = require('noflo/src/lib/Helpers');
  component = require('noflo/src/lib/Component');
  socket = require('noflo/src/lib/InternalSocket');
  Substream = require('noflo/src/lib/Streams').Substream;
}

describe('Component traits', function() {
  describe('MapComponent', function() {
    var c;
    c = null;
    it('should pass data to the callback', function() {
      var s;
      c = new component.Component;
      c.inPorts.add('in');
      c.outPorts.add('out', {
        required: false
      });
      helpers.MapComponent(c, function(data) {
        return chai.expect(data).to.equal(1);
      });
      s = new socket.createSocket();
      c.inPorts["in"].attach(s);
      return s.send(1);
    });
    it('should pass groups to the callback', function() {
      var s;
      c = new component.Component;
      c.inPorts.add('in');
      c.outPorts.add('out', {
        required: false
      });
      helpers.MapComponent(c, function(data, groups) {
        chai.expect(groups).to.eql(['one', 'two']);
        return chai.expect(data).to.equal(1);
      });
      s = new socket.createSocket();
      c.inPorts["in"].attach(s);
      s.beginGroup('one');
      s.beginGroup('two');
      return s.send(1);
    });
    return it('should send groups and disconnect through', function(done) {
      var groups, s, s2;
      c = new component.Component;
      c.inPorts.add('in');
      c.outPorts.add('out', {
        required: false
      });
      helpers.MapComponent(c, function(data, groups, out) {
        return out.send(data * 2);
      });
      s = new socket.createSocket();
      c.inPorts["in"].attach(s);
      s2 = new socket.createSocket();
      c.outPorts.out.attach(s2);
      groups = [];
      s2.on('begingroup', function(group) {
        return groups.push(group);
      });
      s2.on('data', function(data) {
        chai.expect(groups.length).to.equal(2);
        return chai.expect(data).to.equal(6);
      });
      s2.on('endgroup', function() {
        return groups.pop();
      });
      s2.on('disconnect', function() {
        chai.expect(groups.length).to.equal(0);
        return done();
      });
      s.beginGroup('one');
      s.beginGroup('two');
      s.send(3);
      s.endGroup();
      s.endGroup();
      return s.disconnect();
    });
  });
  describe('WirePattern', function() {
    describe('when grouping by packet groups', function() {
      var c, p, x, y, z;
      c = new component.Component;
      c.inPorts.add('x', {
        required: true,
        datatype: 'int'
      });
      c.inPorts.add('y', {
        required: true,
        datatype: 'int'
      });
      c.inPorts.add('z', {
        required: true,
        datatype: 'int'
      });
      c.outPorts.add('point');
      x = new socket.createSocket();
      y = new socket.createSocket();
      z = new socket.createSocket();
      p = new socket.createSocket();
      c.inPorts.x.attach(x);
      c.inPorts.y.attach(y);
      c.inPorts.z.attach(z);
      c.outPorts.point.attach(p);
      it('should pass data and groups to the callback', function(done) {
        var count, groups, grp, key, src, _results;
        src = {
          111: {
            x: 1,
            y: 2,
            z: 3
          },
          222: {
            x: 4,
            y: 5,
            z: 6
          },
          333: {
            x: 7,
            y: 8,
            z: 9
          }
        };
        helpers.WirePattern(c, {
          "in": ['x', 'y', 'z'],
          out: 'point',
          group: true,
          forwardGroups: true
        }, function(data, groups, out) {
          chai.expect(groups.length).to.be.above(0);
          chai.expect(data).to.deep.equal(src[groups[0]]);
          return out.send(data);
        });
        groups = [];
        count = 0;
        p.on('begingroup', function(grp) {
          return groups.push(grp);
        });
        p.on('endgroup', function() {
          return groups.pop();
        });
        p.on('data', function(data) {
          return count++;
        });
        p.on('disconnect', function() {
          if (count === 3 && groups.length === 0) {
            return done();
          }
        });
        _results = [];
        for (key in src) {
          grp = src[key];
          x.beginGroup(key);
          y.beginGroup(key);
          z.beginGroup(key);
          x.send(grp.x);
          y.send(grp.y);
          z.send(grp.z);
          x.endGroup();
          y.endGroup();
          z.endGroup();
          x.disconnect();
          y.disconnect();
          _results.push(z.disconnect());
        }
        return _results;
      });
      it('should work without a group provided', function(done) {
        p.removeAllListeners();
        helpers.WirePattern(c, {
          "in": ['x', 'y', 'z'],
          out: 'point'
        }, function(data, groups, out) {
          chai.expect(groups.length).to.equal(0);
          return out.send({
            x: data.x,
            y: data.y,
            z: data.z
          });
        });
        p.once('data', function(data) {
          chai.expect(data).to.deep.equal({
            x: 123,
            y: 456,
            z: 789
          });
          return done();
        });
        x.send(123);
        x.disconnect();
        y.send(456);
        y.disconnect();
        z.send(789);
        return z.disconnect();
      });
      it('should process inputs for different groups independently with group: true', function(done) {
        var groups, inOrder, input, outOrder, src, tuple, _i, _len, _results;
        src = {
          1: {
            x: 1,
            y: 2,
            z: 3
          },
          2: {
            x: 4,
            y: 5,
            z: 6
          },
          3: {
            x: 7,
            y: 8,
            z: 9
          }
        };
        inOrder = [[1, 'x'], [3, 'z'], [2, 'y'], [2, 'x'], [1, 'z'], [2, 'z'], [3, 'x'], [1, 'y'], [3, 'y']];
        outOrder = [2, 1, 3];
        helpers.WirePattern(c, {
          "in": ['x', 'y', 'z'],
          out: 'point',
          group: true,
          forwardGroups: true
        }, function(data, groups, out) {
          return out.send({
            x: data.x,
            y: data.y,
            z: data.z
          });
        });
        groups = [];
        p.on('begingroup', function(grp) {
          return groups.push(grp);
        });
        p.on('endgroup', function(grp) {
          return groups.pop();
        });
        p.on('data', function(data) {
          chai.expect(groups.length).to.equal(1);
          chai.expect(groups[0]).to.equal(outOrder[0]);
          chai.expect(data).to.deep.equal(src[outOrder[0]]);
          outOrder.shift();
          if (!outOrder.length) {
            return done();
          }
        });
        _results = [];
        for (_i = 0, _len = inOrder.length; _i < _len; _i++) {
          tuple = inOrder[_i];
          input = null;
          switch (tuple[1]) {
            case 'x':
              input = x;
              break;
            case 'y':
              input = y;
              break;
            case 'z':
              input = z;
          }
          input.beginGroup(tuple[0]);
          input.send(src[tuple[0]][tuple[1]]);
          input.endGroup();
          _results.push(input.disconnect());
        }
        return _results;
      });
      it('should support asynchronous handlers', function(done) {
        var counter, hadData, point;
        point = {
          x: 123,
          y: 456,
          z: 789
        };
        helpers.WirePattern(c, {
          "in": ['x', 'y', 'z'],
          out: 'point',
          async: true,
          group: true,
          forwardGroups: true
        }, function(data, groups, out, callback) {
          return setTimeout(function() {
            out.send({
              x: data.x,
              y: data.y,
              z: data.z
            });
            return callback();
          }, 100);
        });
        p.removeAllListeners();
        counter = 0;
        hadData = false;
        p.on('begingroup', function(grp) {
          return counter++;
        });
        p.on('endgroup', function() {
          return counter--;
        });
        p.once('data', function(data) {
          chai.expect(data).to.deep.equal(point);
          return hadData = true;
        });
        p.once('disconnect', function() {
          chai.expect(counter).to.equal(0);
          chai.expect(hadData).to.be["true"];
          return done();
        });
        x.beginGroup('async');
        y.beginGroup('async');
        z.beginGroup('async');
        x.send(point.x);
        y.send(point.y);
        z.send(point.z);
        x.endGroup();
        y.endGroup();
        z.endGroup();
        x.disconnect();
        y.disconnect();
        return z.disconnect();
      });
      it('should not forward groups if forwarding is off', function(done) {
        var counter, hadData, point;
        point = {
          x: 123,
          y: 456
        };
        helpers.WirePattern(c, {
          "in": ['x', 'y'],
          out: 'point'
        }, function(data, groups, out) {
          return out.send({
            x: data.x,
            y: data.y
          });
        });
        p.removeAllListeners();
        counter = 0;
        hadData = false;
        p.on('begingroup', function(grp) {
          return counter++;
        });
        p.on('data', function(data) {
          chai.expect(data).to.deep.equal(point);
          return hadData = true;
        });
        p.once('disconnect', function() {
          chai.expect(counter).to.equal(0);
          chai.expect(hadData).to.be["true"];
          return done();
        });
        x.beginGroup('doNotForwardMe');
        y.beginGroup('doNotForwardMe');
        x.send(point.x);
        y.send(point.y);
        x.endGroup();
        y.endGroup();
        x.disconnect();
        return y.disconnect();
      });
      it('should forward groups from a specific port only', function(done) {
        var groups, point, refGroups;
        point = {
          x: 123,
          y: 456,
          z: 789
        };
        refGroups = ['boo'];
        helpers.WirePattern(c, {
          "in": ['x', 'y', 'z'],
          out: 'point',
          forwardGroups: 'y'
        }, function(data, groups, out) {
          return out.send({
            x: data.x,
            y: data.y,
            z: data.z
          });
        });
        p.removeAllListeners();
        groups = [];
        p.on('begingroup', function(grp) {
          return groups.push(grp);
        });
        p.on('data', function(data) {
          return chai.expect(data).to.deep.equal(point);
        });
        p.once('disconnect', function() {
          chai.expect(groups).to.deep.equal(refGroups);
          return done();
        });
        x.beginGroup('foo');
        y.beginGroup('boo');
        z.beginGroup('bar');
        x.send(point.x);
        y.send(point.y);
        z.send(point.z);
        x.endGroup();
        y.endGroup();
        z.endGroup();
        x.disconnect();
        y.disconnect();
        return z.disconnect();
      });
      return it('should forward groups from selected ports only', function(done) {
        var groups, point, refGroups;
        point = {
          x: 123,
          y: 456,
          z: 789
        };
        refGroups = ['foo', 'bar'];
        helpers.WirePattern(c, {
          "in": ['x', 'y', 'z'],
          out: 'point',
          forwardGroups: ['x', 'z']
        }, function(data, groups, out) {
          return out.send({
            x: data.x,
            y: data.y,
            z: data.z
          });
        });
        p.removeAllListeners();
        groups = [];
        p.on('begingroup', function(grp) {
          return groups.push(grp);
        });
        p.on('data', function(data) {
          return chai.expect(data).to.deep.equal(point);
        });
        p.once('disconnect', function() {
          chai.expect(groups).to.deep.equal(refGroups);
          return done();
        });
        x.beginGroup('foo');
        y.beginGroup('boo');
        z.beginGroup('bar');
        x.send(point.x);
        y.send(point.y);
        z.send(point.z);
        x.endGroup();
        y.endGroup();
        z.endGroup();
        x.disconnect();
        y.disconnect();
        return z.disconnect();
      });
    });
    describe('when in async mode and packet order matters', function() {
      var c, delay, load, msg, out;
      c = new component.Component;
      c.inPorts.add('delay', {
        datatype: 'int'
      });
      c.inPorts.add('msg', {
        datatype: 'string'
      });
      c.outPorts.add('out', {
        datatype: 'object'
      });
      c.outPorts.add('load', {
        datatype: 'int'
      });
      delay = new socket.createSocket();
      msg = new socket.createSocket();
      out = new socket.createSocket();
      load = new socket.createSocket();
      c.inPorts.delay.attach(delay);
      c.inPorts.msg.attach(msg);
      c.outPorts.out.attach(out);
      c.outPorts.load.attach(load);
      it('should preserve input order at the output', function(done) {
        var expected, idx, ip, sample, _i, _len, _results;
        helpers.WirePattern(c, {
          "in": ['delay', 'msg'],
          async: true,
          ordered: true,
          group: false
        }, function(data, groups, res, callback) {
          return setTimeout(function() {
            res.send({
              delay: data.delay,
              msg: data.msg
            });
            return callback();
          }, data.delay);
        });
        sample = [
          {
            delay: 30,
            msg: "one"
          }, {
            delay: 0,
            msg: "two"
          }, {
            delay: 20,
            msg: "three"
          }, {
            delay: 10,
            msg: "four"
          }
        ];
        out.on('data', function(data) {
          return chai.expect(data).to.deep.equal(sample.shift());
        });
        out.on('disconnect', function() {
          if (sample.length === 0) {
            return done();
          }
        });
        expected = [1, 2, 3, 4, 3, 2, 1, 0];
        load.on('data', function(data) {
          return chai.expect(data).to.equal(expected.shift());
        });
        idx = 0;
        _results = [];
        for (_i = 0, _len = sample.length; _i < _len; _i++) {
          ip = sample[_i];
          delay.beginGroup(idx);
          delay.send(ip.delay);
          delay.endGroup();
          msg.beginGroup(idx);
          msg.send(ip.msg);
          msg.endGroup();
          delay.disconnect();
          msg.disconnect();
          _results.push(idx++);
        }
        return _results;
      });
      return it('should support complex substreams', function(done) {
        var expected, i, sample, _i, _results;
        out.removeAllListeners();
        load.removeAllListeners();
        c.cntr = 0;
        helpers.WirePattern(c, {
          "in": ['delay', 'msg'],
          async: true,
          ordered: true,
          group: false,
          receiveStreams: ['delay', 'msg']
        }, function(data, groups, res, callback) {
          var delayData, delayObj, index0, index1, msgData, msgObj, subDelay, subMsg;
          chai.expect(data.delay instanceof Substream).to.be["true"];
          chai.expect(data.msg instanceof Substream).to.be["true"];
          delayObj = data.delay.toObject();
          msgObj = data.msg.toObject();
          index0 = c.cntr.toString();
          chai.expect(Object.keys(delayObj)[0]).to.equal(index0);
          chai.expect(Object.keys(msgObj)[0]).to.equal(index0);
          subDelay = delayObj[index0];
          subMsg = msgObj[index0];
          index1 = (10 + c.cntr).toString();
          chai.expect(Object.keys(subDelay)[0]).to.equal(index1);
          chai.expect(Object.keys(subMsg)[0]).to.equal(index1);
          delayData = subDelay[index1];
          msgData = subMsg[index1];
          chai.expect(delayData).to.equal(sample[c.cntr].delay);
          chai.expect(msgData).to.equal(sample[c.cntr].msg);
          c.cntr++;
          return setTimeout(function() {
            var k0, k1, v0, v1;
            for (k0 in msgObj) {
              v0 = msgObj[k0];
              res.beginGroup(k0);
              res.send(k0);
              for (k1 in v0) {
                v1 = v0[k1];
                res.beginGroup(k1);
                res.send({
                  delay: delayObj[k0][k1],
                  msg: msgObj[k0][k1]
                });
                res.endGroup();
                res.send(k1);
              }
              res.endGroup();
            }
            return callback();
          }, data.delay);
        });
        sample = [
          {
            delay: 30,
            msg: "one"
          }, {
            delay: 0,
            msg: "two"
          }, {
            delay: 20,
            msg: "three"
          }, {
            delay: 10,
            msg: "four"
          }
        ];
        expected = ['0', '0', '10', sample[0], '10', '1', '1', '11', sample[1], '11', '2', '2', '12', sample[2], '12', '3', '3', '13', sample[3], '13'];
        out.on('begingroup', function(grp) {
          return chai.expect(grp).to.equal(expected.shift());
        });
        out.on('data', function(data) {
          return chai.expect(data).to.deep.equal(expected.shift());
        });
        out.on('disconnect', function() {
          if (expected.length === 0) {
            return done();
          }
        });
        _results = [];
        for (i = _i = 0; _i <= 3; i = ++_i) {
          delay.beginGroup(i);
          delay.beginGroup(10 + i);
          delay.send(sample[i].delay);
          delay.endGroup();
          delay.endGroup();
          msg.beginGroup(i);
          msg.beginGroup(10 + i);
          msg.send(sample[i].msg);
          msg.endGroup();
          msg.endGroup();
          delay.disconnect();
          _results.push(msg.disconnect());
        }
        return _results;
      });
    });
    describe('when grouping by field', function() {
      var c, msg, umsg, usr;
      c = new component.Component;
      c.inPorts.add('user', {
        datatype: 'object'
      });
      c.inPorts.add('message', {
        datatype: 'object'
      });
      c.outPorts.add('signedMessage');
      usr = new socket.createSocket();
      msg = new socket.createSocket();
      umsg = new socket.createSocket();
      c.inPorts.user.attach(usr);
      c.inPorts.message.attach(msg);
      c.outPorts.signedMessage.attach(umsg);
      return it('should match objects by specific field', function(done) {
        var counter, mesg, messages, req, user, users, _fn, _results;
        helpers.WirePattern(c, {
          "in": ['user', 'message'],
          out: 'signedMessage',
          async: true,
          field: 'request'
        }, function(data, groups, out, callback) {
          return setTimeout(function() {
            out.send({
              request: data.request,
              user: data.user.name,
              text: data.message.text
            });
            return callback();
          }, 10);
        });
        users = {
          14: {
            request: 14,
            id: 21,
            name: 'Josh'
          },
          12: {
            request: 12,
            id: 25,
            name: 'Leo'
          },
          34: {
            request: 34,
            id: 84,
            name: 'Anica'
          }
        };
        messages = {
          34: {
            request: 34,
            id: 234,
            text: 'Hello world'
          },
          12: {
            request: 12,
            id: 82,
            text: 'Aloha amigos'
          },
          14: {
            request: 14,
            id: 249,
            text: 'Node.js ftw'
          }
        };
        counter = 0;
        umsg.on('data', function(data) {
          chai.expect(data).to.be.an('object');
          chai.expect(data.request).to.be.ok;
          chai.expect(data.user).to.equal(users[data.request].name);
          chai.expect(data.text).to.equal(messages[data.request].text);
          counter++;
          if (counter === 3) {
            return done();
          }
        });
        _fn = function(req, user) {
          return setTimeout(function() {
            usr.send(user);
            return usr.disconnect();
          }, req);
        };
        for (req in users) {
          user = users[req];
          _fn(req, user);
        }
        _results = [];
        for (req in messages) {
          mesg = messages[req];
          _results.push((function(req, mesg) {
            return setTimeout(function() {
              msg.send(mesg);
              return msg.disconnect();
            }, req);
          })(req, mesg));
        }
        return _results;
      });
    });
    describe('when there are multiple output routes', function() {
      var c, even, num, odd, str;
      c = new component.Component;
      c.inPorts.add('num', {
        datatype: 'int'
      });
      c.inPorts.add('str', {
        datatype: 'string'
      });
      c.outPorts.add('odd', {
        datatype: 'object'
      });
      c.outPorts.add('even', {
        datatype: 'object'
      });
      num = new socket.createSocket();
      str = new socket.createSocket();
      odd = new socket.createSocket();
      even = new socket.createSocket();
      c.inPorts.num.attach(num);
      c.inPorts.str.attach(str);
      c.outPorts.odd.attach(odd);
      c.outPorts.even.attach(even);
      return it('should send output to one or more of them', function(done) {
        var dataCounter, grpCounter, i, numbers, _i, _results;
        numbers = ['cero', 'uno', 'dos', 'tres', 'cuatro', 'cinco', 'seis', 'siete', 'ocho', 'nueve'];
        helpers.WirePattern(c, {
          "in": ['num', 'str'],
          out: ['odd', 'even'],
          async: true,
          ordered: true
        }, function(data, groups, outs, callback) {
          return setTimeout(function() {
            var grp, _i, _j, _k, _l, _len, _len1, _len2, _len3;
            if (data.num % 2 === 1) {
              for (_i = 0, _len = groups.length; _i < _len; _i++) {
                grp = groups[_i];
                outs.odd.beginGroup(grp);
              }
              outs.odd.send(data);
              for (_j = 0, _len1 = groups.length; _j < _len1; _j++) {
                grp = groups[_j];
                outs.odd.endGroup();
              }
            } else {
              for (_k = 0, _len2 = groups.length; _k < _len2; _k++) {
                grp = groups[_k];
                outs.even.beginGroup(grp);
              }
              outs.even.send(data);
              for (_l = 0, _len3 = groups.length; _l < _len3; _l++) {
                grp = groups[_l];
                outs.even.endGroup();
              }
            }
            return callback();
          }, 0);
        });
        grpCounter = 0;
        dataCounter = 0;
        odd.on('begingroup', function(grp) {
          return grpCounter++;
        });
        odd.on('data', function(data) {
          chai.expect(data.num % 2).to.equal(1);
          return dataCounter++;
        });
        odd.on('disconnect', function() {
          if (dataCounter === 10 && grpCounter === 10) {
            return done();
          }
        });
        even.on('begingroup', function(grp) {
          return grpCounter++;
        });
        even.on('data', function(data) {
          chai.expect(data.num % 2).to.equal(0);
          chai.expect(data.str).to.equal(numbers[data.num]);
          return dataCounter++;
        });
        even.on('disconnect', function() {
          if (dataCounter === 10 && grpCounter === 10) {
            return done();
          }
        });
        _results = [];
        for (i = _i = 0; _i < 10; i = ++_i) {
          num.beginGroup(i);
          num.send(i);
          num.endGroup(i);
          num.disconnect();
          str.beginGroup(i);
          str.send(numbers[i]);
          str.endGroup(i);
          _results.push(str.disconnect());
        }
        return _results;
      });
    });
    return describe('when there are parameter ports', function() {
      var c, d1, d2, err, out, p1, p2;
      c = null;
      p1 = p2 = d1 = d2 = out = err = 0;
      beforeEach(function() {
        c = new component.Component;
        c.inPorts.add('param1', {
          datatype: 'string',
          required: true
        });
        c.inPorts.add('param2', {
          datatype: 'int',
          required: false
        });
        c.inPorts.add('data1', {
          datatype: 'string'
        });
        c.inPorts.add('data2', {
          datatype: 'int'
        });
        c.outPorts.add('out', {
          datatype: 'object'
        });
        c.outPorts.add('error', {
          datatype: 'object'
        });
        p1 = new socket.createSocket();
        p2 = new socket.createSocket();
        d1 = new socket.createSocket();
        d2 = new socket.createSocket();
        out = new socket.createSocket();
        err = new socket.createSocket();
        c.inPorts.param1.attach(p1);
        c.inPorts.param2.attach(p2);
        c.inPorts.data1.attach(d1);
        c.inPorts.data2.attach(d2);
        c.outPorts.out.attach(out);
        return c.outPorts.error.attach(err);
      });
      it('should wait for required params', function(done) {
        helpers.WirePattern(c, {
          "in": ['data1', 'data2'],
          out: 'out',
          params: ['param1', 'param2']
        }, function(input, groups, out) {
          var res;
          res = {
            p1: c.params.param1,
            p2: c.params.param2,
            d1: input.data1,
            d2: input.data2
          };
          return out.send(res);
        });
        out.once('data', function(data) {
          chai.expect(data).to.be.an('object');
          chai.expect(data.p1).to.equal('req');
          chai.expect(data.p2).to.be.undefined;
          chai.expect(data.d1).to.equal('foo');
          chai.expect(data.d2).to.equal(123);
          return out.once('data', function(data) {
            chai.expect(data).to.be.an('object');
            chai.expect(data.p1).to.equal('req');
            chai.expect(data.p2).to.equal(568);
            chai.expect(data.d1).to.equal('bar');
            chai.expect(data.d2).to.equal(456);
            return done();
          });
        });
        d1.send('foo');
        d2.send(123);
        p1.send('req');
        p2.send(568);
        d1.send('bar');
        return d2.send(456);
      });
      return it('should work for async procs too', function(done) {
        helpers.WirePattern(c, {
          "in": ['data1', 'data2'],
          out: 'out',
          params: ['param1', 'param2']
        }, function(input, groups, out) {
          var delay;
          delay = c.params.param2 ? c.params.param2 : 10;
          return setTimeout(function() {
            var res;
            res = {
              p1: c.params.param1,
              p2: c.params.param2,
              d1: input.data1,
              d2: input.data2
            };
            return out.send(res);
          }, delay);
        });
        out.once('data', function(data) {
          chai.expect(data).to.be.an('object');
          chai.expect(data.p1).to.equal('req');
          chai.expect(data.p2).to.equal(56);
          chai.expect(data.d1).to.equal('foo');
          chai.expect(data.d2).to.equal(123);
          return done();
        });
        p2.send(56);
        d1.send('foo');
        d2.send(123);
        return p1.send('req');
      });
    });
  });
  return describe('MultiError', function() {
    describe('with simple sync processes', function() {
      var c, err, form, saved;
      c = new component.Component;
      c.inPorts.add('form', {
        datatype: 'object'
      }, function(event, payload) {
        if (event !== 'data') {
          return;
        }
        if (!(payload.name && payload.name.match(/^\w{3,16}$/))) {
          c.error(helpers.CustomError('Incorrect name', {
            kind: 'form_error',
            code: 'invalid_name',
            param: 'name'
          }));
        }
        if (!(payload.email && payload.email.match(/^\w+@\w+\.\w+$/))) {
          c.error(helpers.CustomError('Incorrect email', {
            kind: 'form_error',
            code: 'invalid_email',
            param: 'email'
          }));
        }
        if (!payload.accept) {
          c.error(helpers.CustomError('Terms have to be accepted', {
            kind: 'form_error',
            code: 'terms_not_accepted',
            param: 'accept'
          }));
        }
        if (c.hasErrors) {
          return c.fail();
        }
        if (payload.name === 'DelayLama') {
          c.outPorts.saved.send(false);
          c.outPorts.saved.disconnect();
          return c.fail(helpers.CustomError('Suspended for a meditation', {
            kind: 'runtime_error',
            code: 'delay_lama_detected'
          }));
        } else {
          c.outPorts.saved.send(true);
          return c.outPorts.saved.disconnect();
        }
      });
      c.outPorts.add('saved', {
        datatype: 'boolean'
      });
      c.outPorts.add('error', {
        datatype: 'object'
      });
      form = new socket.createSocket();
      saved = new socket.createSocket();
      err = new socket.createSocket();
      c.inPorts.form.attach(form);
      c.outPorts.saved.attach(saved);
      c.outPorts.error.attach(err);
      helpers.MultiError(c);
      it('should support multiple customized error messages', function(done) {
        var errCount;
        errCount = 0;
        err.on('data', function(data) {
          chai.expect(data instanceof Error).to.be["true"];
          chai.expect(data.kind).to.equal('form_error');
          return errCount++;
        });
        err.on('disconnect', function() {
          chai.expect(errCount).to.equal(3);
          return done();
        });
        form.send({
          name: 'Bo',
          email: 'missing'
        });
        return form.disconnect();
      });
      it('should pass if everything is correct', function(done) {
        var hadData;
        hadData = false;
        saved.removeAllListeners();
        saved.once('data', function(data) {
          chai.expect(data).to.be["true"];
          return hadData = true;
        });
        saved.once('disconnect', function() {
          chai.expect(hadData).to.be["true"];
          return done();
        });
        err.removeAllListeners();
        err.on('data', function(data) {
          return done(data);
        });
        form.send({
          name: 'Josh',
          email: 'josh@example.com',
          accept: true
        });
        return form.disconnect();
      });
      return it('should handle fatals and runtimes normally', function(done) {
        var errCount;
        saved.once('data', function(data) {
          return chai.expect(data).to.be["false"];
        });
        err.removeAllListeners();
        errCount = 0;
        err.once('data', function(data) {
          chai.expect(data instanceof Error).to.be["true"];
          chai.expect(data.kind).to.equal('runtime_error');
          return errCount++;
        });
        err.once('disconnect', function() {
          chai.expect(errCount).to.equal(1);
          return done();
        });
        form.send({
          name: 'DelayLama',
          email: 'delay@lama.ti',
          accept: true
        });
        return form.disconnect();
      });
    });
    describe('with async processes and groups', function() {
      var c, err, form, saved;
      c = new component.Component;
      c.inPorts.add('form', {
        datatype: 'object'
      });
      c.outPorts.add('saved', {
        datatype: 'boolean'
      });
      c.outPorts.add('error', {
        datatype: 'object'
      });
      form = new socket.createSocket();
      saved = new socket.createSocket();
      err = new socket.createSocket();
      c.inPorts.form.attach(form);
      c.outPorts.saved.attach(saved);
      c.outPorts.error.attach(err);
      helpers.WirePattern(c, {
        "in": 'form',
        out: 'saved',
        async: true,
        forwardGroups: true
      }, function(payload, groups, out, callback) {
        if (!(payload.name && payload.name.match(/^\w{3,16}$/))) {
          c.error(helpers.CustomError('Incorrect name', {
            kind: 'form_error',
            code: 'invalid_name',
            param: 'name'
          }), groups);
        }
        if (!(payload.email && payload.email.match(/^\w+@\w+\.\w+$/))) {
          c.error(helpers.CustomError('Incorrect email', {
            kind: 'form_error',
            code: 'invalid_email',
            param: 'email'
          }), groups);
        }
        if (!payload.accept) {
          c.error(helpers.CustomError('Terms have to be accepted', {
            kind: 'form_error',
            code: 'terms_not_accepted',
            param: 'accept'
          }), groups);
        }
        if (c.hasErrors) {
          return callback(false);
        }
        return setTimeout(function() {
          if (payload.name === 'DelayLama') {
            out.send(false);
            return callback(helpers.CustomError('Suspended for a meditation', {
              kind: 'runtime_error',
              code: 'delay_lama_detected'
            }));
          } else {
            out.send(true);
            return callback();
          }
        }, 10);
      });
      helpers.MultiError(c, 'Registration');
      it('should support multiple error messages and groups', function(done) {
        var actual, errCount, expected;
        expected = ['Registration', 'async0', 'async0', 'async0'];
        actual = [];
        errCount = 0;
        err.on('begingroup', function(grp) {
          return actual.push(grp);
        });
        err.on('data', function(data) {
          chai.expect(data instanceof Error).to.be["true"];
          chai.expect(data.kind).to.equal('form_error');
          return errCount++;
        });
        err.on('disconnect', function() {
          chai.expect(errCount).to.equal(3);
          chai.expect(actual).to.deep.equal(expected);
          return done();
        });
        form.beginGroup('async0');
        form.send({
          name: 'Bo',
          email: 'missing'
        });
        form.endGroup();
        return form.disconnect();
      });
      it('should pass if everything is correct', function(done) {
        var hadData;
        hadData = false;
        saved.removeAllListeners();
        saved.once('data', function(data) {
          chai.expect(data).to.be["true"];
          return hadData = true;
        });
        saved.once('disconnect', function() {
          chai.expect(hadData).to.be["true"];
          return done();
        });
        err.removeAllListeners();
        err.on('data', function(data) {
          return done(data);
        });
        form.send({
          name: 'Josh',
          email: 'josh@example.com',
          accept: true
        });
        return form.disconnect();
      });
      return it('should handle fatals and runtimes normally', function(done) {
        var errCount, grpCount;
        saved.once('data', function(data) {
          return chai.expect(data).to.be["false"];
        });
        err.removeAllListeners();
        errCount = 0;
        grpCount = 0;
        err.on('begingroup', function(grp) {
          chai.expect(grp).to.equal('Registration');
          return grpCount++;
        });
        err.once('data', function(data) {
          chai.expect(data instanceof Error).to.be["true"];
          chai.expect(data.kind).to.equal('runtime_error');
          return errCount++;
        });
        err.once('disconnect', function() {
          chai.expect(errCount).to.equal(1);
          chai.expect(grpCount).to.equal(1);
          return done();
        });
        form.send({
          name: 'DelayLama',
          email: 'delay@lama.ti',
          accept: true
        });
        return form.disconnect();
      });
    });
    return describe('with many inputs and groups', function() {
      var c, err, ins, msg, out, pth, rep, tkn;
      c = new component.Component;
      c.token = null;
      c.inPorts.add('in', {
        datatype: 'string'
      });
      c.inPorts.add('message', {
        datatype: 'string'
      });
      c.inPorts.add('repository', {
        datatype: 'string'
      });
      c.inPorts.add('path', {
        datatype: 'string'
      });
      c.inPorts.add('token', {
        datatype: 'string'
      }, function(event, payload) {
        if (event === 'data') {
          return c.token = payload;
        }
      });
      c.outPorts.add('out', {
        datatype: 'string'
      });
      c.outPorts.add('error', {
        datatype: 'object'
      });
      helpers.WirePattern(c, {
        "in": ['in', 'message', 'repository', 'path'],
        out: 'out',
        async: true,
        forwardGroups: true
      }, function(data, groups, out, callback) {
        return setTimeout(function() {
          out.beginGroup(data.path);
          out.send(data.message);
          out.endGroup();
          return callback();
        }, 300);
      });
      ins = socket.createSocket();
      msg = socket.createSocket();
      rep = socket.createSocket();
      pth = socket.createSocket();
      tkn = socket.createSocket();
      out = socket.createSocket();
      err = socket.createSocket();
      c.inPorts["in"].attach(ins);
      c.inPorts.message.attach(msg);
      c.inPorts.repository.attach(rep);
      c.inPorts.path.attach(pth);
      c.inPorts.token.attach(tkn);
      c.outPorts.out.attach(out);
      c.outPorts.error.attach(err);
      return it('should handle mixed flow well', function(done) {
        var ends, groups, packets, refData, refGroups;
        groups = [];
        refGroups = ['foo', 'http://techcrunch.com/2013/03/26/embedly-now/', 'path data'];
        ends = 0;
        packets = [];
        refData = ['message data'];
        out.on('begingroup', function(grp) {
          return groups.push(grp);
        });
        out.on('endgroup', function() {
          return ends++;
        });
        out.on('data', function(data) {
          return packets.push(data);
        });
        out.on('disconnect', function() {
          chai.expect(groups).to.deep.equal(refGroups);
          chai.expect(ends).to.equal(3);
          chai.expect(packets).to.deep.equal(refData);
          return done();
        });
        err.on('data', function(data) {
          return done(data);
        });
        rep.beginGroup('foo');
        rep.beginGroup('http://techcrunch.com/2013/03/26/embedly-now/');
        rep.send('repo data');
        rep.endGroup();
        rep.endGroup();
        ins.beginGroup('foo');
        ins.beginGroup('http://techcrunch.com/2013/03/26/embedly-now/');
        ins.send('ins data');
        msg.beginGroup('foo');
        msg.beginGroup('http://techcrunch.com/2013/03/26/embedly-now/');
        msg.send('message data');
        msg.endGroup();
        msg.endGroup();
        ins.endGroup();
        ins.endGroup();
        ins.disconnect();
        msg.disconnect();
        pth.beginGroup('foo');
        pth.beginGroup('http://techcrunch.com/2013/03/26/embedly-now/');
        pth.send('path data');
        pth.endGroup();
        pth.endGroup();
        pth.disconnect();
        return rep.disconnect();
      });
    });
  });
});
